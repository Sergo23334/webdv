-- phpMyAdmin SQL Dump
-- version 4.8.4
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1
-- Время создания: Янв 03 2019 г., 11:41
-- Версия сервера: 10.1.37-MariaDB
-- Версия PHP: 7.0.33

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `webdv`
--

-- --------------------------------------------------------

--
-- Структура таблицы `comments`
--

CREATE TABLE `comments` (
  `id` int(11) NOT NULL,
  `comment` text NOT NULL,
  `code` text NOT NULL,
  `theme` text NOT NULL,
  `user` text NOT NULL,
  `date` text NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `comments`
--

INSERT INTO `comments` (`id`, `comment`, `code`, `theme`, `user`, `date`) VALUES
(31, '1', '', '70', 'admin55', '03.01.2019'),
(30, 'Hello World!', '&lt;php\n  echo &quot;Hello World!&quot;;\n?&gt;', '70', 'admin55', '03.01.2019'),
(29, 'sadsadsdalololo', '', '70', 'admin55', '03.01.2019'),
(28, 'admin55', '', '70', 'admin55', '03.01.2019'),
(27, 'admin55', '', '70', 'admin55', '03.01.2019');

-- --------------------------------------------------------

--
-- Структура таблицы `theme`
--

CREATE TABLE `theme` (
  `id` int(11) NOT NULL,
  `name` text NOT NULL,
  `discription` text NOT NULL,
  `shortdisc` text NOT NULL,
  `code` text NOT NULL,
  `user` text NOT NULL,
  `date` text NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `theme`
--

INSERT INTO `theme` (`id`, `name`, `discription`, `shortdisc`, `code`, `user`, `date`) VALUES
(70, '         PHP', 'PHP (/pi:.eɪtʃ.pi:/ англ. PHP: Hypertext Preprocessor — «PHP: препроцессор гипертекста»; первоначально Personal Home Page Tools[8] — «Инструменты для создания персональных веб-страниц») — скриптовый язык[9] общего назначения, интенсивно применяемый для разработки веб-приложений. В настоящее время поддерживается подавляющим большинством хостинг-провайдеров и является одним из лидеров среди языков, применяющихся для создания динамических веб-сайтов[10].\r\n\r\nЯзык и его интерпретатор (Zend Engine) разрабатываются группой энтузиастов в рамках проекта с открытым кодом[11]. Проект распространяется под собственной лицензией, несовместимой с GNU GPL.\r\nОбласть применения\r\nВ области веб-программирования, в частности серверной части, PHP — один из популярных сценарных языков (наряду с JSP, Perl и языками, используемыми в ASP.NET).\r\n\r\nПопулярность в области построения веб-сайтов определяется наличием большого набора встроенных средств для разработки веб-приложений[12]. Основные из них:\r\n\r\nавтоматическое извлечение POST и GET-параметров, а также переменных окружения веб-сервера в предопределённые массивы;\r\nвзаимодействие с большим количеством различных систем управления базами данных (MySQL, MySQLi, SQLite, PostgreSQL, Oracle (OCI8), Oracle, Microsoft SQL Server, Sybase, ODBC, mSQL, IBM DB2, Cloudscape и Apache Derby, Informix, Ovrimos SQL, Lotus Notes, DB++, DBM, dBase, DBX, FrontBase, FilePro, Ingres II, SESAM, Firebird / InterBase, Paradox File Access, MaxDB, Интерфейс PDO), Redis;\r\nавтоматизированная отправка HTTP-заголовков;\r\nработа с HTTP-авторизацией;\r\nработа с cookies и сессиями;\r\nработа с локальными и удалёнными файлами, сокетами;\r\nобработка файлов, загружаемых на сервер;\r\nработа с XForms.\r\nВ настоящее время PHP используется сотнями тысяч разработчиков. Согласно рейтингу корпорации TIOBE, базирующемся на данных поисковых систем, в мае 2016 года PHP находился на 6 месте среди языков программирования[10]. К крупнейшим сайтам, использующим PHP, относятся Facebook, Wikipedia и др.\r\n\r\nВходит в LAMP — распространённый набор программного обеспечения для создания и хостинга веб-сайтов (Linux, Apache, MySQL, PHP).\r\n\r\nСоздание GUI-приложений\r\n\r\nСкриншот редактора форм WinBinder\r\nХотя PHP и не слишком распространён в данной области, его можно использовать и для создания GUI-приложений.\r\n\r\nДля создания кроссплатформенных приложений служат пакеты PHP-GTK и PHP-Qt, представляющие собой обёртки для соответствующих популярных библиотек виджетов. Также существует среда разработки кроссплатформенных приложений Devel Next[13].\r\n\r\nДля создания графических приложений для Windows существуют свободные пакеты WinBinder (написан на Си, фактически — обёртка для WinAPI), PQBuilder (написан на PHP с использованием библиотеки PHPQt5), а также предшественник Devel Next — среда быстрой разработки Devel Studio[14].\r\n\r\nКроме этого существует реализация PHP для .NET/Mono — Phalanger и для JVM — JPHP, результатом компиляции PHP-кода в Phalanger может быть любое .NET-приложение, в то же время JPHP поддерживает расширение Swing, почти полностью портированное из среды Java.\r\n\r\nИстория\r\nОсновная статья: История PHP\r\nВ 1994 году датский программист Расмус Лердорф создал набор скриптов на Perl/CGI для вывода и учёта посетителей его онлайн-резюме, обрабатывающий шаблоны HTML-документов. Лердорф назвал набор Personal Home Page (Личная Домашняя Страница). Вскоре функциональности и быстроты Perl — интерпретатора скриптов — перестало хватать, и Лердорф разработал с использованием языка C новый интерпретатор шаблонов PHP/FI (англ. Personal Home Page / Forms Interpreter — «персональная домашняя страница / интерпретатор форм»)[15].\r\n\r\n8 июня 1995 года, вышел Personal Home Page (PHP Tools) version 1.0 — первый публичный релиз.\r\n\r\nВ 1997 году после длительного бета-тестирования вышла вторая версия обработчика, написанного на C — PHP/FI 2.0. Её использовали около 1 % (приблизительно 50 тысяч) всех интернет-доменов мира[8].\r\n\r\nВерсия PHP 3.0 подверглась значительной переработке, определившей современный облик и стиль языка программирования. В 1997 году два израильских программиста, Энди Гутманс и Зеев Сураски, полностью переписали код интерпретатора. PHP 3.0 был официально выпущен в июне 1998 года.[8]\r\n\r\nОдной из сильнейших сторон PHP 3.0 была возможность расширения ядра дополнительными модулями. Впоследствии интерфейс написания расширений привлёк к PHP множество сторонних разработчиков, работающих над своими модулями, что дало PHP возможность работать с огромным количеством баз данных, протоколов, поддерживать большое число API. Большое количество разработчиков привело к быстрому развитию языка и стремительному росту его популярности. С этой версии акроним php расшифровывается как «PHP: hypertext Preprocessor», вместо устаревшего «Personal Home Page».\r\n\r\nК зиме 1998 года, практически сразу после официального выхода PHP 3.0, Энди Гутманс и Зеев Сураски начали переработку ядра PHP. В задачи входило увеличение производительности сложных приложений и улучшение модульности базиса кода PHP. Новый движок, названн', 'PHP (/pi:.eɪtʃ.pi:/ англ. PHP: Hypertext Preprocessor — «PHP: препроцессор гипертекста»; первоначально Personal Home Page Tools[8] — «Инструменты для создания персональных веб-страниц») — скриптовый язык[9] общего назначения, интенсивно применяемый для разработки веб-приложений. В настоящее время...', '&lt;?php\r\n  echo \'Hello, world!\'; \r\n?&gt;\r\n\r\n//Также возможен более короткий вариант вывода строки:\r\n\r\n&lt;?= \'Hello, world!\' ?&gt;', 'admin', '01.01.2019'),
(68, 'Вывод текста на экран в PHP.', 'Используем языковую конструкцию &quot;echo&quot; для вывода текста на экран.', 'Используем языковую конструкцию &quot;echo&quot; для вывода текста на экран.', '&lt;?php\r\n  $name = &quot;Sergo&quot;;\r\n\r\n  echo &quot;Hello $name!&quot;; //Hello Sergo!\r\n\r\n  echo &quot;Hello &quot;.$name.&quot;!&quot;; //Hello Sergo!(с объединением строк)\r\n?&gt;', 'admin', '31.12.2018'),
(69, 'PHP и HTML', 'Какое кодирование/декодирование я должен выполнять при передаче значения через форму/URL?\r\nЗдесь несколько этапов, на которых кодировка важна. Предположим, что у вас есть $data типа string, содержащая строку, которую вы хотите передать без кодирования. Вот эти этапы:\r\n\r\nИнтерпретация HTML. Для того, чтобы задать произвольную строку, вы должны заключить её в двойные кавычки и использовать htmlspecialchars() для кодирования.\r\n\r\nURL: URL состоит из нескольких частей. Если вы хотите чтобы ваши данные были восприняты как один элемент, вы должны закодировать их с помощью urlencode().\r\nЯ пытаюсь использовать &lt;input type=&quot;image&quot;&gt;, но переменные $foo.x и $foo.y недоступны. $_GET[\'foo.x\'] тоже не существует. Где они?\r\nПри отправке формы, вместо стандартной кнопки отправки возможно использовать изображение с тэгом как:\r\n\r\n&lt;input type=&quot;image&quot; src=&quot;image.gif&quot; name=&quot;foo&quot; /&gt;\r\nКогда пользователь кликает где-либо на картинке, серверу будет послана сопутствующая форма с двумя дополнительными переменными: foo.x и foo.y.\r\nТак как имена foo.x и foo.y не разрешены в PHP, они автоматически преобразуются в foo_x и foo_y. То есть, точки заменяются на подчёркивания. Таким образом, вы обращаетесь к этим переменным так же, как и к любым другим, описанным в разделе о получении переменных извне PHP. Например, $_GET[\'foo_x\'].\r\n\r\nЗамечание:\r\n\r\nПробелы в именах переменных запроса преобразуются в подчёркивания.\r\nКак создать массивы в HTML &lt;form&gt;?\r\nДля того, чтобы результаты &lt;form&gt; были переданы вашему PHP скрипту как массив, именуйте элементы &lt;input&gt;, &lt;select&gt; или &lt;textarea&gt; следующим образом:\r\n\r\n&lt;input name=&quot;MyArray[]&quot; /&gt;\r\n&lt;input name=&quot;MyArray[]&quot; /&gt;\r\n&lt;input name=&quot;MyArray[]&quot; /&gt;\r\n&lt;input name=&quot;MyArray[]&quot; /&gt;\r\nЗаметьте квадратные скобки после имени переменной, это делает её массивом. Вы можете сгруппировать элементы в массив, присваивая одно и то же имя разным элементам:\r\n&lt;input name=&quot;MyArray[]&quot; /&gt;\r\n&lt;input name=&quot;MyArray[]&quot; /&gt;\r\n&lt;input name=&quot;MyOtherArray[]&quot; /&gt;\r\n&lt;input name=&quot;MyOtherArray[]&quot; /&gt;\r\nЭто создаст два массива, MyArray и MyOtherArray, которые будут переданы PHP-скрипту. Также возможно задать определенные ключи для ваших массивов:\r\n&lt;input name=&quot;AnotherArray[]&quot; /&gt;\r\n&lt;input name=&quot;AnotherArray[]&quot; /&gt;\r\n&lt;input name=&quot;AnotherArray[email]&quot; /&gt;\r\n&lt;input name=&quot;AnotherArray[phone]&quot; /&gt;\r\nМассив AnotherArray теперь будет содержать ключи 0, 1, email и phone.\r\nЗамечание:\r\n\r\nОпределять ключи массивов в HTML необязательно. Если вы не установите ключи, массив заполняется в порядке появления элементов в форме. Наш первый пример будет содержать ключи 0, 1, 2 и 3.\r\n\r\nТакже смотрите Функции для работы с массивами и Переменные извне PHP.\r\n\r\nКак получить все результаты из HTML-тега select с атрибутом multiple?\r\nHTML-тег select с указанным multiple позволяет пользователю выбрать несколько элементов из списка. Эти элементы затем передаются обработчику формы. Проблема в том, что они все переданы с одним и тем же именем. Например:\r\n\r\n&lt;select name=&quot;var&quot; multiple=&quot;yes&quot;&gt;\r\nКаждая выбранная опция поступит обработчику формы как:\r\nvar=option1\r\nvar=option2\r\nvar=option3\r\n      \r\nКаждая опция будет перезаписывать содержимое предыдущей переменной $var. Решение - воспользоваться возможностью PHP - &quot;массив из элемента формы&quot;. Следует использовать следующее:\r\n&lt;select name=&quot;var[]&quot; multiple=&quot;yes&quot;&gt;\r\nЭто укажет PHP обрабатывать $var как массив и каждое присваивание значения в var[] добавит элемент в массив. Первым элементом будет $var[0], следующим - $var[1] и т.д. Функция count() может быть использована для определения, сколько элементов было выбрано, а функция sort() - для сортировки массива опций, если это необходимо.\r\nЗаметьте, что если вы используете JavaScript, то [] в имени элемента могут вызвать проблемы, если вы пытаетесь обращаться к элементу по имени. Вместо этого используйте числовой идентификатор элемента формы или заключите имя переменной в одинарные кавычки и используйте его как индекс массива элементов, например:\r\n\r\nvariable = document.forms[0].elements[\'var[]\'];\r\n      \r\nКак я могу передать переменную из JavaScript в PHP?\r\nТак как JavaScript является (обычно) клиентской технологией, а PHP, как правило, серверной, и поскольку HTML - протокол &quot;без состояния&quot;, эти два языка не могут обмениваться переменными напрямую.\r\n\r\nОднако, возможно передавать переменные между ними. Один из способов достичь этого - сгенерировать JavaScript-код из PHP и принудительно обновлять браузер, посылая определённые переменные обратно PHP-скрипту. Нижеприведенный пример показывает как это сделать - он позволяет PHP-коду получить высоту и ширину экрана, что, обычно, возможно только на стороне клиента.\r\n', 'Какое кодирование/декодирование я должен выполнять при передаче значения через форму/URL?\r\nЗдесь несколько этапов, на которых кодировка важна. Предположим, что у вас есть $data типа string, содержащая строку, которую вы хотите передать без кодирования. Вот эти этапы:\r\n\r\nИнтерпретация HTML. Для то...', '&lt;?php\r\n    echo \'&lt;a href=&quot;\' . htmlspecialchars(&quot;/nextpage.php?stage=23&amp;data=&quot; .\r\n        urlencode($data)) . \'&quot;&gt;\'.&quot;\\n&quot;;\r\n?&gt;\r\n\r\n&lt;?php\r\nif (isset($_GET[\'width\']) AND isset($_GET[\'height\'])) {\r\n  // выводим переменные с размерами\r\n  echo &quot;Ширина экрана: &quot;. $_GET[\'width\'] .&quot;&lt;br /&gt;\\n&quot;;\r\n  echo &quot;Высота экрана: &quot;. $_GET[\'height\'] .&quot;&lt;br /&gt;\\n&quot;;\r\n} else {\r\n  // передаем переменные с размерами\r\n  // (сохраняем оригинальную строку запроса\r\n  //   -- post переменные нужно будет передавать другим способом)\r\n\r\n  echo &quot;&lt;script language=\'javascript\'&gt;\\n&quot;;\r\n  echo &quot;  location.href=\\&quot;${_SERVER[\'SCRIPT_NAME\']}?${_SERVER[\'QUERY_STRING\']}&quot;\r\n            . &quot;&amp;width=\\&quot; + screen.width + \\&quot;&amp;height=\\&quot; + screen.height;\\n&quot;;\r\n  echo &quot;&lt;/script&gt;\\n&quot;;\r\n  exit();\r\n}\r\n?&gt;', 'admin', '01.01.2019'),
(67, 'Безопасность баз данных', 'Вступление\r\n\r\nНа сегодняшний день базы данных являются ключевыми компонентами большинства веб-приложений, позволяя предоставлять на сайтах динамический контент. Поскольку в таких БД может храниться очень точная или конфиденциальная информация, вы должны обеспечить хорошую защиту данных.\r\n\r\nДля извлечения или сохранения любых данных вам необходимо открыть соединение с базой данных, отправить верный запрос, извлечь результат и закрыть соединение. В настоящее время наиболее распространенный стандарт общения - структурированный язык запросов (SQL). Всегда следует помнить о возможности атаки посредством SQL-запроса (SQL-инъекция).\r\n\r\nОчевидно, что сам по себе PHP не может защитить вашу базу данных. Этот раздел документации рассказывает об основах безопасного доступа и управления данными в PHP-скриптах.\r\n\r\nЗапомните простое правило: максимальная защита. Чем больше потенциально опасных участков системы вы проработаете, тем сложнее будет потенциальному взломщику получить доступ к базе данных или повредить ее. Хороший дизайн базы данных и программных приложений поможет вам справиться с вашими страхами.\r\n\r\nПроектирование базы данных\r\n\r\nПервый шаг - это всегда создание БД, исключая тот случай, когда вы хотите использовать готовую базу, предоставляемую третьим лицом. После того, как база данных создана, она назначается пользователю, который выполнил создавший БД запрос. Как правило, только владелец (или суперпользователь) может выполнять различные действия с различными объектами, хранимыми в базе данных. Для того, чтобы и другие пользователи имели к ней доступ, их необходимо наделить соответствующими привелегиями.\r\n\r\nПриложения не должны соединяться с базой данных, используя учетную запись владельца или суперпользователя, иначе они смогут модифицировать структуру таблиц (например, удалить некоторые таблицы) или даже удалить все содержимое БД целиком.\r\n\r\nВы можете создать различные учетные записи пользователей БД для каждой индивидуальной потребности приложения с соответствующими функциональными ограничениями. Рекомендуется назначать только самые необходимые привилегии, также вы должны избегать ситуаций, когда один и тот же пользователь может взаимодействовать с базой данных в нескольких режимах. Вы должны понимать, что если злоумышленник сможет воспользоваться какой-либо учетной записью вашей БД, он сможет вносить в базу все те изменения, что и программа, которая использует текущую учетную запись.\r\n\r\nВам не обязательно реализовывать всю бизнес-логику в веб-приложении (т.е. в скриптах), для этого также можно использовать возможности, предоставляемые базой данных: триггеры, представления, правила. В случае роста системы вам понадобятся новые соединения с БД, и логику работы понадобиться дублировать для каждого нового интерфейса доступа. Исходя из вышесказанного, триггеры могут использоваться для прозрачной и автоматической обработки записей, что часто необходимо при отладке приложений или при трассировке отката транзакций.\r\n\r\nСоединение с базой данных\r\n\r\nВы можете использовать безопасные SSL или ssh соединения, для шифрования данных, которыми обмениваются клиент и сервер. Если вы реализуете что-нибудь из этого, то мониторинг трафика и сбор данных о вашей базе данных для потенциального взломщика существенно усложнится.\r\n\r\nЗащита хранилища базы данных\r\n\r\nSSL/SSH защищает данные, которыми обмениваются клиент и сервер, но не защищают сами данные, хранимые в базе данных. SSL - протокол шифрования на уровне сеанса передачи данных.\r\n\r\nВ случае, если взломщик получил непосредственный доступ к БД (в обход веб-сервера), он может извлечь интересующие данные или нарушить их целостность, поскольку информация не защищена на уровне самой БД. Шифрование данных - хороший способ предотвратить такую ситуацию, но лишь незначительное количество БД предоставляют такую возможность.\r\n\r\nНаиболее простое решение этой проблемы - установить вначале обыкновенный программный пакет для шифрования данных, а затем использовать его в ваших скриптах. PHP, в таком случае, может помочь вам в работе с такими расширениями как Mcrypt и Mhash, реализующими различные алгоритмы криптования. При таком подходе скрипт вначале шифрует сохраняемые данные, а затем дешифрует их при запросе. Ниже приведены примеры того, как работает шифрование данных в PHP-скриптах.\r\n\r\nВ случае работы со скрытыми служебными данными их нешифрованное представление не требуется (т.е. не отображается), и, как следствие, можно использовать хеширование. Хорошо известный пример хэширования - хранение MD5-хеша от пароля в БД, вместо хранения оригинального значения. Более детальная информация доступна в описании функций crypt() and md5().', 'Вступление\r\n\r\nНа сегодняшний день базы данных являются ключевыми компонентами большинства веб-приложений, позволяя предоставлять на сайтах динамический контент. Поскольку в таких БД может храниться очень точная или конфиденциальная информация, вы должны обеспечить хорошую защиту данных.\r\n\r\nДля из...', '&lt;?php\r\n// сохранение хешированного пароля\r\n$query  = sprintf(&quot;INSERT INTO users(name,pwd) VALUES(\'%s\',\'%s\');&quot;,\r\n            addslashes($username), md5($password));\r\n$result = pg_exec($connection, $query);\r\n\r\n// проверка введенного пользователем логина и пароля на корректность\r\n$query = sprintf(&quot;SELECT 1 FROM users WHERE name=\'%s\' AND pwd=\'%s\';&quot;,\r\n            addslashes($username), md5($password));\r\n$result = pg_exec($connection, $query);\r\n\r\nif (pg_numrows($result) &gt; 0) {\r\n    echo &quot;Welcome, $username!&quot;;\r\n}\r\nelse {\r\n    echo &quot;Authentication failed for $username.&quot;;\r\n}\r\n?&gt;\r\n\r\n', 'admin', '31.12.2018'),
(71, 'Типы данных', 'PHP является языком программирования с динамической типизацией, не требующим указания типа при объявлении переменных, равно как и самого объявления переменных. Преобразования между скалярными типами зачастую осуществляются неявно без дополнительных усилий (впрочем, PHP предоставляет широкие возможности и для явного преобразования типов).\r\n\r\nК скалярным типам данных относятся:\r\n\r\nцелочисленный тип (integer)\r\nчисло с плавающей точкой (float, double)\r\nлогический тип (boolean)\r\nстроковый тип (string)\r\nК нескалярным типам относятся:\r\n\r\nмассив (array)\r\nобъект (object)\r\nвнешний ресурс (resource)\r\nнеопределенное значение (null)\r\nК псевдотипам[28] относятся:\r\n\r\nmixed любой тип\r\nnumber число (integer либо float)\r\ncallback (string или анонимная функция)\r\nvoid отсутствие параметров\r\nДиапазон целых чисел (integer) в PHP зависит от платформы (обычно, это диапазон 32-битных знаковых целых чисел, то есть, от −2 147 483 648 до 2 147 483 647). Числа можно задавать в десятичной, восьмеричной и шестнадцатеричной системах счисления. Диапазон вещественных чисел (double) также зависит от платформы (для 32-битной архитектуры диапазон позволяет оперировать числами от ±1.7×10−308 до ±1.7×10+308).\r\n\r\nPHP предоставляет разработчикам логический тип (boolean), способный принимать только два значения TRUE («истина») и FALSE («ложь»). При преобразовании в логический тип число 0, пустая строка, ноль в строке «0», NULL и пустой массив считаются равными FALSE. Все остальные значения автоматически преобразуются в TRUE.\r\n\r\nСпециальный тип null предназначен для переменных без определённого значения. Единственным значением данного типа является константа NULL. Тип null принимают неинициализированные переменные, переменные инициализированные константой NULL, а также переменные, удалённые при помощи конструкции unset().\r\n\r\nСсылки на внешние ресурсы имеют тип «ресурс» (resource). Переменные данного типа, как правило, представляют собой дескриптор, позволяющий управлять внешними объектами, такими как файлы, динамические изображения, результирующие таблицы базы данных и т. п.\r\n\r\nМассивы (array) поддерживают числовые и строковые ключи и являются гетерогенными. Массивы могут содержать значения любых типов, включая другие массивы. Порядок элементов и их ключей сохраняется. Не совсем корректно называть php-массивы массивами, на самом деле это, скорее всего, упорядоченный хеш. Возможно неожиданное поведение при использовании цикла for со счетчиком вместо foreach. Так, например, при сортировке массива с численными индексами функциями из стандартной библиотеки, сортируются и ключи тоже.\r\n\r\nУказатель на функцию в PHP может быть представлен замыканием или псевдотипом callback. Замыкание доступно с версии 5.3 и в коде выглядит как простое определение функции, в которую можно явно пробросить значения из контекста, например:\r\n\r\n function($args, $argsN) use ($ctxVar, $ctxVar1) { ... }\r\ncallback тип может быть представлен:\r\n\r\nстрокой (интерпретируется как название функции);\r\nмассивом где нулевой и первый элемент — строки (интерпретируется как название статической функции класса);\r\nмассивом где нулевой элемент — объект, а первый — строка (интерпретируется как метод у объекта).\r\nДля проверки является ли значение вызываемым следует использовать is_callable($var)', 'PHP является языком программирования с динамической типизацией, не требующим указания типа при объявлении переменных, равно как и самого объявления переменных. Преобразования между скалярными типами зачастую осуществляются неявно без дополнительных усилий (впрочем, PHP предоставляет широкие возмо...', '', 'admin', '01.01.2019'),
(72, 'htmlspecialchars', 'В HTML некоторые символы имеют специальное значение и для сохранения своего значения должны быть преобразованы в HTML сущности. Эта функция возвращает строку, над которой проведены некоторые из таких преобразований. Этих преобразований достаточно для большинства задач веб-программирования. Если вам нужно преобразовать все возможные сущности, используйте htmlentities().\r\n\r\n\r\n Эта функция полезна при отображении данных, введенных пользователем, которые могут содержать нежелательные HTML тэги, например в форуме или гостевой книге. Необязательный второй аргумент quote_style определяет режим обработки одиночных и двойных кавычек. В режиме по умолчанию, ENT_COMPAT, преобразуются двойные кавычки, одиночные остаются без изменений. В режиме ENT_QUOTES преобразуются и двойные, и одиночные кавычки. а в режиме ENT_NOQUOTES и двойные, и одиночные кавычки остаются без изменений.\r\n\r\n\r\n Производятся следующие преобразования:\r\n\r\n\r\n \'&amp;\' (амперсанд) преобразуется в \'&amp;amp;\'\r\n\r\n\r\n \'&quot;\' (двойная кавычка) преобразуется в \'&amp;quot;\' when ENT_NOQUOTES is not set.\r\n\r\n\r\n \'\'\' (одиночная кавычка) преобразуется в \'&amp;#039;\' только в режиме ENT_QUOTES.\r\n\r\n\r\n \'&lt;\' (знак &quot;меньше чем&quot;) преобразуется в \'&amp;lt;\'\r\n\r\n\r\n \'&gt;\' (знак &quot;больше чем&quot;) преобразуется в \'&amp;gt;\'', 'В HTML некоторые символы имеют специальное значение и для сохранения своего значения должны быть преобразованы в HTML сущности. Эта функция возвращает строку, над которой проведены некоторые из таких преобразований. Этих преобразований достаточно для большинства задач веб-программирования. Если в...', 'Пример 1. Пример использования htmlspecialchars()\r\n\r\n&lt;?php\r\n$new = htmlspecialchars(&quot;&lt;a href=\'test\'&gt;Test&lt;/a&gt;&quot;, ENT_QUOTES);\r\necho $new; // &amp;lt;a href=&amp;#039;test&amp;#039;&amp;gt;Test&amp;lt;/a&amp;gt;\r\n?&gt;', 'admin55', '02.01.2019'),
(73, 'feSADWASASADADSASD', 'SADADSSAADSADSADSASDSADSADSDASDSADSADSADSDASDSDASAD', 'SADADSSAADSADSADSASDSADSADSDASDSADSADSADSDASDSDASAD', '', 'admin55', '02.01.2019'),
(74, 'feSADWASASADADSASD', 'SADADSSAADSADSADSASDSADSADSDASDSADSADSADSDASDSDASAD', 'SADADSSAADSADSADSASDSADSADSDASDSADSADSADSDASDSDASAD', '', 'admin55', '02.01.2019'),
(75, 'dassssssssssssssssssssssssss', 'assssssssssssssssssssssssssassssssssssssssssssssssssssassssssssssssssssssssssssssassssssssssssssssssssssssss', 'assssssssssssssssssssssssssassssssssssssssssssssssssssassssssssssssssssssssssssssassssssssssssssssssssssssss', '', 'admin55', '02.01.2019'),
(76, '$newId$newId$newId$newId$newId', '$newId$newId$newId$newId$newId$newId$newId$newId$newId', '$newId$newId$newId$newId$newId$newId$newId$newId$newId', '', 'admin55', '02.01.2019'),
(77, '$newId$newId$newId', '$newId$newId$newId$newId$newId$newId$newId$newId$newId$newId$newId$newId', '$newId$newId$newId$newId$newId$newId$newId$newId$newId$newId$newId$newId', '', 'admin55', '02.01.2019'),
(78, 'admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55', 'admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin5admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin555admin55', 'admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin5admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admi...', 'admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55admin55', 'admin55', '02.01.2019'),
(79, 'admin55admin55admin55admin55', 'admin55admin55admin55admin55admin55', 'admin55admin55admin55admin55admin55', '', 'admin55', '02.01.2019');

-- --------------------------------------------------------

--
-- Структура таблицы `users`
--

CREATE TABLE `users` (
  `id` int(11) NOT NULL,
  `name` text NOT NULL,
  `surname` text NOT NULL,
  `age` int(3) NOT NULL,
  `country` text NOT NULL,
  `city` text NOT NULL,
  `mail` text NOT NULL,
  `tel` bigint(16) NOT NULL,
  `login` text NOT NULL,
  `pass` text NOT NULL,
  `key` text NOT NULL,
  `date` text NOT NULL
) ENGINE=MyISAM DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `users`
--

INSERT INTO `users` (`id`, `name`, `surname`, `age`, `country`, `city`, `mail`, `tel`, `login`, `pass`, `key`, `date`) VALUES
(16, 'admin', 'adminovskyi', 18, 'Ukraine', 'Kyiv', 'earlofdarkness23334@gmail.com', 380953243078, 'admin', '19dbabf8191cb477e8070780791d831d', '6', '21:13/30.12.2018'),
(17, 'testuser', 'testov', 18, 'Ukraine', 'Kyiv', 'ero-sannin@ukr.net', 380953243539, 'admin55', 'ceccc0a53a1d2ebbc911128ebafcce41', 'v', '21:21/30.12.2018');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `comments`
--
ALTER TABLE `comments`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `theme`
--
ALTER TABLE `theme`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `comments`
--
ALTER TABLE `comments`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=32;

--
-- AUTO_INCREMENT для таблицы `theme`
--
ALTER TABLE `theme`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=80;

--
-- AUTO_INCREMENT для таблицы `users`
--
ALTER TABLE `users`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=18;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
